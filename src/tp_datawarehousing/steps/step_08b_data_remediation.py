"""
Step 08b - Data Remediation: Orquestador de remediaci√≥n autom√°tica de problemas de calidad.

Este paso se ejecuta despu√©s del step_08 (carga de Ingesta2) para detectar y remediar
autom√°ticamente los problemas de calidad identificados en el DQM.

Problemas que resuelve:
1. SCD2 Temporal Logic: Fechas de inicio > fin
2. Missing Regions: Clientes sin regi√≥n asignada  
3. Missing Shipping Data: Datos de env√≠o incompletos

Autor: Claude Code (Data Remediation Rockstar üé∏)
"""

import logging
from datetime import datetime
from tp_datawarehousing.quality_utils import (
    get_process_execution_id,
    update_process_execution,
    log_quality_metric
)
from tp_datawarehousing.data_remediation_utils import (
    fix_scd2_temporal_logic,
    resolve_missing_regions,
    handle_missing_shipping_data,
    create_remediation_report,
    validate_remediation_results,
    RemediationStats,
    # üöÄ NUEVAS FUNCIONES DE REMEDIACI√ìN AVANZADA
    advanced_geographic_remediation,
    advanced_contact_data_remediation,
    world_data_enrichment_remediation
)

def main():
    """
    üöÄ FUNCI√ìN PRINCIPAL DE REMEDIACI√ìN AVANZADA DE DATOS
    
    Flujo de remediaci√≥n EXPANDIDO:
    1. Inicia proceso de ejecuci√≥n en DQM
    2. Ejecuta correcciones SCD2 (b√°sicas)
    3. Resuelve regiones faltantes (b√°sicas)
    4. Maneja datos de env√≠o incompletos (b√°sicas)
    5. üåç NUEVA: Remediaci√≥n geogr√°fica avanzada
    6. üìß NUEVA: Remediaci√≥n de datos de contacto
    7. üåé NUEVA: Enriquecimiento de world data
    8. Valida que las correcciones se aplicaron
    9. Genera reporte consolidado AVANZADO
    10. Actualiza estado final en DQM
    """
    
    # Configuraci√≥n de logging espec√≠fico para este step
    logging.info("=" * 70)
    logging.info("üîß INICIANDO PROCESO DE REMEDIACI√ìN DE DATOS")
    logging.info("=" * 70)
    
    # Inicializar tracking de ejecuci√≥n
    execution_id = get_process_execution_id("STEP_08B_DATA_REMEDIATION")
    if execution_id is None:
        logging.error("‚ùå No se pudo obtener ID de ejecuci√≥n para el proceso de remediaci√≥n")
        return False
    
    try:
        # === FASE 1: CORRECCI√ìN DE L√ìGICA TEMPORAL SCD2 ===
        logging.info("üïê Fase 1: Corrigiendo problemas de l√≥gica temporal SCD2...")
        scd2_stats = fix_scd2_temporal_logic(execution_id)
        
        if scd2_stats.scd2_fixes > 0:
            logging.info(f"   ‚úÖ Corregidos {scd2_stats.scd2_fixes} registros SCD2")
        else:
            logging.info("   ‚ÑπÔ∏è No se encontraron problemas SCD2 que corregir")
        
        # === FASE 2: RESOLUCI√ìN DE REGIONES FALTANTES ===
        logging.info("üåç Fase 2: Resolviendo regiones faltantes...")
        region_stats = resolve_missing_regions(execution_id)
        
        if region_stats.region_fixes > 0:
            logging.info(f"   ‚úÖ Asignadas regiones a {region_stats.region_fixes} clientes")
        else:
            logging.info("   ‚ÑπÔ∏è No se encontraron clientes sin regi√≥n")
        
        # === FASE 3: MANEJO DE DATOS DE ENV√çO FALTANTES ===
        logging.info("üì¶ Fase 3: Manejando datos de env√≠o incompletos...")
        shipping_stats = handle_missing_shipping_data(execution_id)
        
        if shipping_stats.shipping_fixes > 0:
            logging.info(f"   ‚úÖ Procesadas {shipping_stats.shipping_fixes} √≥rdenes con problemas de env√≠o")
        else:
            logging.info("   ‚ÑπÔ∏è No se encontraron problemas de datos de env√≠o")
        
        # === üöÄ FASE 4: REMEDIACI√ìN GEOGR√ÅFICA AVANZADA ===
        logging.info("üåç Fase 4: Ejecutando remediaci√≥n geogr√°fica avanzada...")
        geographic_stats = advanced_geographic_remediation(execution_id)
        
        if geographic_stats.get_total_fixes() > 0:
            logging.info(f"   ‚úÖ Remediaci√≥n geogr√°fica: {geographic_stats.get_total_fixes()} fixes aplicados")
            logging.info(f"      ‚Ä¢ Regiones geogr√°ficas: {geographic_stats.null_geographic_fixes}")
            logging.info(f"      ‚Ä¢ Propagaci√≥n ship_region: {geographic_stats.pattern_based_fixes}")
            logging.info(f"      ‚Ä¢ Fuzzy matching: {geographic_stats.fuzzy_match_fixes}")
        else:
            logging.info("   ‚ÑπÔ∏è No se encontraron problemas geogr√°ficos que corregir")
        
        # === üìß FASE 5: REMEDIACI√ìN DE DATOS DE CONTACTO ===
        logging.info("üìß Fase 5: Ejecutando remediaci√≥n de datos de contacto...")
        contact_stats = advanced_contact_data_remediation(execution_id)
        
        if contact_stats.get_total_fixes() > 0:
            logging.info(f"   ‚úÖ Datos de contacto generados: {contact_stats.get_total_fixes()} entradas")
        else:
            logging.info("   ‚ÑπÔ∏è No se encontraron datos de contacto faltantes")
        
        # === üåé FASE 6: ENRIQUECIMIENTO DE WORLD DATA ===
        logging.info("üåé Fase 6: Ejecutando enriquecimiento de world data...")
        world_data_stats = world_data_enrichment_remediation(execution_id)
        
        if world_data_stats.get_total_fixes() > 0:
            logging.info(f"   ‚úÖ World data enriquecido: {world_data_stats.get_total_fixes()} estimaciones")
        else:
            logging.info("   ‚ÑπÔ∏è No se encontraron oportunidades de enriquecimiento")
        
        # === FASE 7: VALIDACI√ìN DE REMEDIACIONES ===
        logging.info("üîç Fase 7: Validando que las correcciones se aplicaron...")
        validation_passed = validate_remediation_results(execution_id)
        
        if validation_passed:
            logging.info("   ‚úÖ Validaci√≥n exitosa: Todas las correcciones se aplicaron correctamente")
        else:
            logging.warning("   ‚ö†Ô∏è Validaci√≥n con advertencias: Revisar logs para detalles")
        
        # === FASE 8: GENERACI√ìN DE REPORTE CONSOLIDADO AVANZADO ===
        logging.info("üìä Fase 8: Generando reporte consolidado avanzado...")
        report = create_remediation_report(execution_id, scd2_stats, region_stats, shipping_stats,
                                         geographic_stats, contact_stats, world_data_stats)
        
        # Determinar estado final del proceso EXPANDIDO
        basic_fixes = scd2_stats.scd2_fixes + region_stats.region_fixes + shipping_stats.shipping_fixes
        advanced_fixes = (geographic_stats.get_total_fixes() + contact_stats.get_total_fixes() + 
                         world_data_stats.get_total_fixes())
        total_fixes = basic_fixes + advanced_fixes
        
        if total_fixes > 0:
            final_status = "Exitoso"
            final_comments = f"Remediaci√≥n AVANZADA completada: {report['summary']['total_fixes_applied']} fixes total. Categor√≠as resueltas: {report['summary']['problem_categories_resolved']}/{report['summary']['problem_categories_total']}. Status: {report['summary']['status']}"
            logging.info(f"üéâ REMEDIACI√ìN AVANZADA COMPLETADA EXITOSAMENTE!")
        else:
            final_status = "Exitoso"
            final_comments = "No se detectaron problemas de calidad que requerir remediaci√≥n"
            logging.info("‚ÑπÔ∏è REMEDIACI√ìN COMPLETADA: No se encontraron problemas que corregir")
        
        # Registrar m√©tricas finales
        log_quality_metric(
            execution_id=execution_id,
            nombre_indicador="REMEDIATION_PROCESS_SUMMARY",
            entidad_asociada="DATA_REMEDIATION",
            resultado=report['summary']['status'],
            detalles=f"Total fixes: {total_fixes}. Resolution rate: {report['summary']['resolution_rate_percent']}%"
        )
        
        # === FINALIZACI√ìN ===
        update_process_execution(execution_id, final_status, final_comments)
        
        # Reporte final CORREGIDO para el usuario
        logging.info("=" * 70)
        logging.info("üìã RESUMEN FINAL DE REMEDIACI√ìN (M√âTRICAS CORREGIDAS):")
        logging.info(f"   üìÇ Categor√≠as resueltas: {report['summary']['problem_categories_resolved']}/{report['summary']['problem_categories_total']}")
        logging.info(f"   üìä Tasa de resoluci√≥n por categor√≠a: {report['summary']['resolution_rate_percent']}%")
        logging.info(f"   üîß Total de fixes aplicados: {report['summary']['total_fixes_applied']}")
        logging.info(f"   üìà Mejora de calidad vs baseline: {report['summary']['data_quality_improvement_percent']}%")
        logging.info(f"   üì¶ BREAKDOWN DE FIXES:")
        logging.info(f"      ‚Ä¢ B√°sicos: {report['breakdown']['basic_fixes']['basic_total']} fixes")
        logging.info(f"        - SCD2: {scd2_stats.scd2_fixes}, Regiones: {region_stats.region_fixes}, Shipping: {shipping_stats.shipping_fixes}")
        logging.info(f"      ‚Ä¢ Avanzados: {report['breakdown']['advanced_fixes']['advanced_total']} fixes")
        logging.info(f"        - Geogr√°ficos: {geographic_stats.get_total_fixes()}, Contacto: {contact_stats.get_total_fixes()}, World data: {world_data_stats.get_total_fixes()}")
        logging.info(f"   ‚úÖ Estado final: {report['summary']['status']}")
        logging.info("=" * 70)
        
        return True
        
    except Exception as e:
        error_msg = f"Error cr√≠tico en proceso de remediaci√≥n: {str(e)}"
        logging.error(f"‚ùå {error_msg}")
        
        # Registrar error en DQM
        log_quality_metric(
            execution_id=execution_id,
            nombre_indicador="REMEDIATION_PROCESS_ERROR",
            entidad_asociada="DATA_REMEDIATION",
            resultado="CRITICAL_ERROR",
            detalles=error_msg
        )
        
        # Actualizar estado de ejecuci√≥n
        update_process_execution(execution_id, "Fallido", error_msg)
        return False

def run_remediation_diagnostics():
    """
    Funci√≥n auxiliar para ejecutar solo diagn√≥sticos sin aplicar correcciones.
    √ötil para an√°lisis previo de problemas.
    """
    from tp_datawarehousing.quality_utils import get_db_connection
    
    logging.info("üîç EJECUTANDO DIAGN√ìSTICOS DE REMEDIACI√ìN...")
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Diagn√≥stico 1: Problemas SCD2
        cursor.execute("""
            SELECT COUNT(*) FROM DWA_DIM_Clientes 
            WHERE fecha_inicio_validez > fecha_fin_validez
        """)
        scd2_issues = cursor.fetchone()[0]
        logging.info(f"   üìÖ Problemas SCD2 temporal: {scd2_issues} registros")
        
        # Diagn√≥stico 2: Regiones faltantes
        cursor.execute("""
            SELECT COUNT(*) FROM TMP2_customers 
            WHERE region IS NULL OR region = ''
        """)
        region_issues = cursor.fetchone()[0]
        logging.info(f"   üåç Clientes sin regi√≥n: {region_issues} registros")
        
        # Diagn√≥stico 3: Datos de env√≠o
        cursor.execute("""
            SELECT 
                SUM(CASE WHEN ship_region IS NULL THEN 1 ELSE 0 END) as sin_region,
                SUM(CASE WHEN ship_postal_code IS NULL THEN 1 ELSE 0 END) as sin_postal,
                SUM(CASE WHEN shipped_date IS NULL THEN 1 ELSE 0 END) as sin_fecha
            FROM TMP2_orders
        """)
        shipping_stats = cursor.fetchone()
        sin_region, sin_postal, sin_fecha = shipping_stats
        logging.info(f"   üì¶ √ìrdenes con problemas: regi√≥n:{sin_region}, postal:{sin_postal}, fecha:{sin_fecha}")
        
        total_issues = scd2_issues + region_issues + sin_region + sin_postal
        logging.info(f"   üìä TOTAL ISSUES DETECTADOS: {total_issues}")
        
        conn.close()
        return total_issues
        
    except Exception as e:
        logging.error(f"Error en diagn√≥sticos: {e}")
        return -1

if __name__ == "__main__":
    """
    Permite ejecutar el step de forma independiente para testing.
    
    Uso:
    python -m tp_datawarehousing.steps.step_08b_data_remediation
    """
    
    # Configurar logging para ejecuci√≥n independiente
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s"
    )
    
    logging.info("üöÄ Ejecutando Step 08b - Data Remediation de forma independiente")
    
    # Ejecutar diagn√≥sticos primero
    issues_detected = run_remediation_diagnostics()
    
    if issues_detected > 0:
        logging.info(f"üíä Se detectaron {issues_detected} problemas. Iniciando remediaci√≥n...")
        success = main()
        
        if success:
            logging.info("üéâ Remediaci√≥n completada exitosamente!")
        else:
            logging.error("‚ùå La remediaci√≥n fall√≥. Revisar logs para detalles.")
    elif issues_detected == 0:
        logging.info("‚úÖ No se detectaron problemas de calidad. Sistema en buen estado.")
    else:
        logging.error("‚ùå Error ejecutando diagn√≥sticos.")